## 一、密码基础知识
	- ### 1.1 密码学发展
		- **1.1.1 凯撒密码**
			- **平移替换**：按照字母表每一个字母向后平移N位，例如有一串明文abc，平移后变为DEF。同样是连续的。
		- **1.1.2 简单替换密码**
			- **密码对应表**：消息双方保存一份密码的对应表，在对应表中说明密码的对应关系，例如a对应D,b对应2，c对应G。那么bc加密后就位D2G。这个对应关系只有消息双方知道。
		- **1.1.3 enigma**
			- **密码机算法**（二战德国使用）：消息的发送方和接收方有一个密码本（可以理解为对称加密中的秘钥），上面记载每日的密码。发送方通过其进行加密，接收方通过其进行解密。
			- ![image.png](../assets/image_1710173000718_0.png)
	- ### 1.2 对称加密
		- **1.2.1 DES加密**
			- 典型的对称加密方式。原理是把需要加密的原始数据，以8字节(64bit)进行分割，每8字节，都按照如下的方式进行16轮的加密，注意是16轮。每一轮加密，都将8字节分为前/后32bit，后32bit无需任何加密，直接作为下一轮的前32bit。前32bit需要和后32bit以及本轮子秘钥（每轮子秘钥不一样）的轮函数结果，做异或运算，得到结果作为下一轮的后32bt,以此类推。
			- ![image.png](../assets/image_1710173395144_0.png)
		- **1.2.2 3DES加密**
			- 在DES加密的基础上，进行“DES加密-DES解密-DES加密”，且每轮使用的秘钥均不一样；
			- ![image.png](../assets/image_1710173554445_0.png)
		- **1.2.3 AES加密**
			- 对称加密算法主流趋势。AES的分组长度是128bit（16字节），也就是以16字节为单位，采用多轮Rijndeal加密和解密。这里以一轮为案例进行说明：
				- 在每一轮，将16个字节分为四组，每一组进行平移，平移之后每一个字节与轮秘钥进行异或处理，输出加密后的16字节。
				- ![image.png](../assets/image_1710173667962_0.png)
	- ### 1.3对称加密迭代模式
		- 原始数据长度不一，若原始数据多于基本单位长度如何迭代，以下介绍主要的迭代方式：
		- **1.3.1 ECB**
			- 每个明文分组都独立地执行加解密操作，相同的明文分组，密文分组也相同.
			- 每一组互不干扰。最后一组如果不够单位长度，padding填充，如下图：
			- ![image.png](../assets/image_1710174021021_0.png)
		- **1.3.2 CBC（使用比较多）**
			- CBC全称为cipher block chaining，即密文分组是像链条一样相互连接在一起的。该模式下，首先将明文分组与前一个密文分组进行异或运算，然后再进行加密。
			- 第一个分组需要初始化向量-IV，IV与第一分组的明文进行异或运算，然后加密。如下图：
			- ![image.png](../assets/image_1710174107086_0.png)
			- ```
			  1.加密需要串行执行：在没有获得上一个明文分组对应的密文分组前，下一个明文分组无法被加密。
			  2.解密可以并行执行；尽管解密每个密文分组时需要与前一个密文分组进行异或，但所有密文分组在解密时都是已经知道的。
			  3.密文比明文长：由于需要包括IV的信息，CBC模式下加密的结果通常会超过原始的明文。
			  ```
		- **1.3.3 CTR**
			- 通过逐次累加计数器进行加密来生成密钥流的流密码。其加密流程如下图：
			- ![image.png](../assets/image_1710174503614_0.png)
			- CTR每次加密时都会生成一个不同的nonce作为计数器的初值，当分组长度为16字节时，计数器的初始值可能为如下形式：
			- ![image.png](../assets/image_1710175116741_0.png)
			- 其中，前8个字节为nonce，它在每次加密时必须是不同的，后8个字节为分组序号，它会在加密过程中逐次累加。
			- ```
			  CTR模式加密和解密使用完全相同的结构，在程序和硬件上便于实现。
			  CTR模式可以以任意顺序对分组执行加解密，因此其可以充分利用并行计算.
			  ```
		- **1.3.4 CFB模式**
			- CFB全称为cipher feedback，即前一个密文的分组会被送到密码算法的输入端。
			- 该模式下，首先对前一个分组的密文加密，然后与下一个分组的明文异或。其加密流程如下图：
			- ![image.png](../assets/image_1710174707845_0.png)
			- 其明文分组到密文分组之间只有一个异或操作，而并没有直接对明文分组执行加密操作。CFB模式可被攻击者用于重放攻击，如以下示例中若攻击者用老的分组替换了后三个分组，则最终解密后的第三和第四个分组数据将会被替换，如下图：
			- ![image.png](../assets/image_1710174839922_0.png)
		- **1.3.5 OFB模式**
			- OFB全称为output-feedback，它不通过密码算法对明文直接加密，而是通过将明文分组与密码算法的输出进行异或来产生密文分组。其加密流程如下图：
			- ![image.png](../assets/image_1710174944321_0.png)
			- ```
			  1.OFB模式的优点为密钥流生成和异或计算可以并行执行。
			  若提前准备好了密钥流，则对明文分组的异或运算会非常快。因此，OFB模式的加密速度较快。
			  2.OFB使用时必须确保每次使用不同的IV值，否则也可能被重放攻击。
			  ```
		- **1.3.6 分组密码算法模式比较**
			- ![image.png](../assets/image_1710175186105_0.png)
- ## 二、前后端密码处理逻辑
	- 在一次 http 请求中，前后端如何安全传输密码？服务器端如何安全存储密码？以下介绍几种方案：
	- **2.1 明文传输、存储**
		- （1）大致步骤
			- ```
			  - 用户：提供用户名和密码。
			  - 前端：密码明文传输。
			  - 后端：用户注册：①前端传输密码明文&用户名，②接收密码进行明文存储。
			         用户登录：①读取数据库中密码，②与接收的密码进行比较以验证登录。
			  ```
			- ![image.png](../assets/image_1710175569574_0.png)
		- （2）优缺点
			- 没任何安全性可言，裸奔密码。请求被抓包，密码即暴露；数据库泄露，密码即暴露。
	- **2.2 单向哈希后传输、存储**
		- （1）大致步骤
			- ```
			  - 用户：提供用户名和密码。
			  - 前端：密码经单向哈希后再发送给后端服务器。
			  - 后端：用户注册：①前端进行哈希加密传输密码哈希值&用户名，②接收密码哈希值进行存储。
			         用户登录：①读取数据库中哈希值，②与接收的密码哈希值进行比较以验证登录。
			  ```
			- ![image.png](../assets/image_1710175774446_0.png)
		- （2）优缺点
			- 相比明文传输、存储，这个方式有了最基础安全防范。但密码的单向哈希，且存储时未加盐。密码容易被暴力穷举检索出来，如彩虹表攻击。现在主流的彩虹表都是100G以上了。
	- **2.3 加盐存储**
		- （1）大致步骤
			- ```
			  - 用户：提供用户名和密码。
			  - 前端：密码经单向哈希后再发送给后端服务器。
			  - 后端：用户注册：①生成随机盐，加入到接收的哈希值中，经单向哈希后生成哈希值2；②存储盐值、哈希值2；
			         用户登录：①读取数据库中盐值，加入到接收的密码哈希值中，经单向哈希后生成哈希值2；②与库中哈希值2进行比较以验证登录。
			  ```
			- ![image.png](../assets/image_1710176149219_0.png)
		- （2）优缺点
			- 优点：密码加盐可以有效地防止彩虹表攻击。即使攻击者知道了盐的内容和加盐的位置，加盐仍然大大增加了利用彩虹表攻击的难度。使数据库泄露，密码仍然具有一定的安全性。
			- 缺点：多次请求，传输的哈希值总是固定的，并没有“加盐”保护。由于http请求的特性，不能直接对密码“加盐”，需要引入非对称加密。
	- **2.4 非对称加密后传输后，加盐存储-基础版**
		- （1）大致步骤
			- ```
			  - 用户：提供用户名和密码。
			  - 前端：注册账号或登录时，①生成随机值；②密码经单向哈希后，与生成的随机值一起，经公钥加密后，生成密文，③将密文发送给后端服务器。
			  - 后端：用户注册：①使用私钥解密密文，丢掉随机值，得到哈希值；②生成随机盐，加入到哈希值中，经单向哈希后生成哈希值2；③存储盐值、哈希值2；
			         用户登录：①使用私钥解密密文，丢掉随机值，得到哈希值；②读取数据库中盐值，加入到哈希值中，经单向哈希后生成哈希值2；③与库中哈希值2进行比较以验证登录。
			  ```
		- ![image.png](../assets/image_1710176444642_0.png)
		- （2）优缺点
			- ①引入随机值，每次传输的密文不同，RSA加密对于其加密的明文的长度有限制。
			- ②非对称加解密需要一些开销。
			- ③需要维护公钥。、
	- **2.4 非对称加密后传输后，加盐存储-改进版**
		- （1）大致步骤
			- ```
			  - 用户：提供用户名和密码。
			  - 前端：注册账号或登录时，①随机生成对称加密密钥；②密码经单向哈希后，进行对称加密，生成密文；③随机生成的对称加密密钥经公钥加密后，生成签名；④将密文、签名一起发送给后端服务器。
			  - 后端：用户注册：①使用私钥解密签名，得到对称加密密钥；②使用对称密钥解密密文，得到哈希值；③生成随机盐，加入到哈希值中，经单向哈希后生成哈希值2；④存储盐值、哈希值2；
			  　　　  用户登录：①使用私钥解密签名，得到对称加密密钥；②使用对称密钥解密密文，得到哈希值；③读取数据库中盐值，加入到哈希值中，经单向哈希后生成哈希值2；④与库中哈希值2进行比较以验证登录。
			  ```
			- ![image.png](../assets/image_1710176910248_0.png)
		- （2）优缺点
			- 优点：虽仍需维护公钥，但传输的数据将不再有限制（即使是https，也有维护公钥的成本）。
			- 缺点：开销进一步加大。
	- **2.5 Https**
		- https 通过2次请求完成对公钥的验证以及对“对称加密的密钥”的约定，之后才发送数据，且继续使用密钥：
		- （1）第一次请求：服务器返回含公钥的证书；客户端验证证书（与本地的证书进行比较），决定是否发起第二次请求；
		- （2）第二次请求：客户端使用公钥加密“对称加密的密钥”，再发送给服务器，以约定之后使用的“对称加密的密钥”。
		- 而后续的请求与返回，使用约定好的对称加密的密钥来加密要传输的数据【将继续使用对称加密】。
-